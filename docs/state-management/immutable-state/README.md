# 불변 상태 관리 (Immutable State Management)

> 상태는 직접 수정하지 말고, **복사본을 만들어 교체**하자.

---

## 개념 정의

- 상태를 직접 수정하지 않고, 기존 상태의 복사본을 만들어 일부만 수정한 **새 객체**로 교체하는 방식

---

## 왜 불변 상태를 유지해야 하는가?

### 1. UI 리렌더링 감지

- 객체 주소가 바뀌어야 상태 변경을 감지함
- 직접 수정하면 리렌더링 안 될 수 있음

### 2. 상태 변경 추적 쉬움

- 상태 변경은 `copyWith()`나 `setState()` 같은 **한정된 경로**에서만 발생 -> 디버깅과 유지보수가 쉬워짐

### 3. 예측 가능한 동작

- 어디서 어떤 값이 바뀌었는지 명확
- 사이드 이펙트(예기치 않은 상태 변경) 방지

### 4. 테스트 가능성 높음

- 상태 이전/이후를 명확하게 비교 가능

---

## mutable vs immutable 비교

| 항목           | Mutable (가변)               | Immutable (불변)       |
| -------------- | ---------------------------- | ---------------------- |
| 상태 변경 방식 | 객체 내부 직접 수정          | 복사본 생성 후 교체    |
| UI 감지 여부   | 주소 동일하면 감지 실패 가능 | 주소 변경 -> 항상 감지 |
| 추적/디버깅    | 언제 바뀌었는지 추적 어려움  | 변경 지점이 명확       |
| 사이드 이펙트  | 발생 가능                    | 거의 없음              |

## 잘못된 예시 (상태 값을 직접 수정)

```dart
// Flutter
state.list.add(photo);

// React
list.push(item);
setList(list); // 같은 주소 -> UI 안 바뀔 수 있음
```

## 올바른 방식 (불변: 복사본으로 새 객체 만들기)

```dart
// Flutter
state = state.copyWith(list: [...state.list, photo]);

// React
setList([...list, item]);
```

## 계속 새 객체 만들면 메모리 낭비 아닌가? -> NO

- 참조가 끊긴 객체는 GC(Garbage Collector)가 자동 해제
- 이전 상태는 더 이상 사용되지 않기 때문에 쌓이지 않음
- 상태 객체는 대부분 가볍기 때문에 성능 문제 거의 없음

## 정리

- 불변 상태 관리는 안정성, 예측 가능성, 성능을 위한 기본 원칙
- React, Flutter 등 상태 기반 UI 프레임워크에서는 필수적
- 실수 예방, 유지보수성 향상을 위해 copyWith / spread 연산자 등 불변 패턴을 적극 사용
